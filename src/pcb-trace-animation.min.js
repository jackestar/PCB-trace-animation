class PCBTraceAnimation{constructor(i,t={}){this.traceElement=i,this.options={traceColor:t.traceColor||t.color||"#000",viaColor:t.viaColor||t.color||"#000",autoResize:void 0===t.autoResize||t.autoResize,speed:t.speed||4,gridResolution:t.gridResolution||Math.max(2,t.lineWidth||3),lineSpacing:t.lineSpacing||10,minLength:t.minLength||10,lineWidth:t.lineWidth||3,lineMargin:t.lineMargin||10,lineAngleVariation:t.lineAngleVariation||.008,lineEndCoefficient:t.lineEndCoefficient||.005},this.lines=[],this.history=[],this.ctx=i.getContext("2d"),this.width=0,this.height=0,this.grid=null,this.gridCols=0,this.gridRows=0,this.PIQ=Math.PI/4,this.PIT=2*Math.PI,this.PIH=Math.PI/2,this.animationFrameId=null,this.running=!1,this.resizeObserver=null}initCanvas(){this.width=window.innerWidth,this.height=window.innerHeight,this.traceElement.width=this.width,this.traceElement.height=this.height,this.ctx.lineCap="round",this.gridCols=Math.ceil(this.width/this.options.gridResolution),this.gridRows=Math.ceil(this.height/this.options.gridResolution),this.grid=new Uint8Array(this.gridCols*this.gridRows)}restart(){this.initCanvas(),this.lines=[],this.history.forEach((i=>{this._drawTrace(...i)}))}markGrid(i,t){if(i<0||i>=this.width||t<0||t>=this.height)return;const s=i/this.options.gridResolution|0,e=t/this.options.gridResolution|0;s>=0&&s<this.gridCols&&e>=0&&e<this.gridRows&&(this.grid[e*this.gridCols+s]=1)}getGridCoords(i,t){return{gx:i/this.options.gridResolution|0,gy:t/this.options.gridResolution|0}}isColliding(i,t){if(i<0||i>=this.width||t<0||t>=this.height)return!0;const s=i/this.options.gridResolution|0,e=t/this.options.gridResolution|0;return!(s>=0&&s<this.gridCols&&e>=0&&e<this.gridRows)||1===this.grid[e*this.gridCols+s]}markLineSegment(i,t,s,e){const n=Math.hypot(s-i,e-t),h=Math.ceil(n/(.8*this.options.gridResolution));for(let n=0;n<=h;n++){const o=n/h,r=i+(s-i)*o,a=t+(e-t)*o;this.markGrid(r,a)}}drawVia(i,t){this.ctx.fillStyle=this.options.viaColor,this.ctx.beginPath();const s=this.options.lineWidth;this.ctx.arc(i,t,s,0,this.PIT),this.ctx.fill()}drawLine(i,t,s,e=!0,n=!1){this.history.push([i,t,s,e,n]),this._drawTrace(i,t,s,e,n)}_drawTrace(i,t,s,e,n){const h=this.width*i,o=this.height*t,r=e?this.width*s:this.height*s,a=h+(e?r:0),l=o+(e?0:r);this.ctx.strokeStyle=this.options.traceColor,this.ctx.lineWidth=this.options.lineWidth,this.ctx.beginPath(),this.ctx.moveTo(h,o),this.ctx.lineTo(a,l),this.ctx.stroke(),this.markLineSegment(h,o,a,l);const d=this.options.lineSpacing+this.options.lineWidth,g=(r-this.options.lineMargin)/d;let c=this.options.lineMargin+(e?h:o);for(let i=0;i<g;i++){const i=e?c:h,t=e?o:c;this.markGrid(i,t),this.lines.push({x:i,y:t,angle:(n?Math.PI:0)+(e?this.PIH:0)}),c+=d}}frame(){for(let i=this.lines.length-1;i>=0;i--){const t=this.lines[i],s=Math.cos(t.angle)*this.options.speed,e=Math.sin(t.angle)*this.options.speed,n=t.x+s,h=t.y+e,o=this.options.speed+this.options.gridResolution/2,r=t.x+Math.cos(t.angle)*o,a=t.y+Math.sin(t.angle)*o,l=this.getGridCoords(t.x,t.y),d=this.getGridCoords(r,a);if((l.gx!==d.gx||l.gy!==d.gy)&&this.isColliding(r,a))this.lines.splice(i,1);else{if(this.ctx.strokeStyle=this.options.traceColor,this.ctx.lineWidth=this.options.lineWidth,this.ctx.beginPath(),this.ctx.moveTo(t.x,t.y),this.ctx.lineTo(n,h),this.ctx.stroke(),this.markLineSegment(t.x,t.y,n,h),t.x=n,t.y=h,Math.random()<this.options.lineAngleVariation){const i=Math.random()<.5?-this.PIQ:this.PIQ;t.angle=(t.angle+i+this.PIT)%this.PIT}Math.random()<this.options.lineEndCoefficient&&(this.lines.splice(i,1),this.drawVia(t.x,t.y))}}}start(){if(this.running)return;this.initCanvas(),this.options.autoResize&&"undefined"!=typeof ResizeObserver&&(this.resizeObserver&&this.resizeObserver.disconnect(),this.resizeObserver=new ResizeObserver((()=>{this.running&&this.restart()})),this.resizeObserver.observe(this.traceElement)),this.running=!0;const i=()=>{this.running&&(this.frame(),this.animationFrameId=requestAnimationFrame(i))};i()}stop(){this.running=!1,this.animationFrameId&&cancelAnimationFrame(this.animationFrameId),this.resizeObserver&&this.resizeObserver.disconnect()}}