class PCBMaker{constructor(i,t="Center"){this.canvas=i,this.location=t,this.color="#000",this.autoResize=!0,this.autoFitSizes=!0,this.squareSize=0,this.lineSpeed=4,this.lineSpacing=10,this.minLength=2*this.lineSpeed,this.lineWidth=3,this.endCoefficient=.005,this.CustomPosX=0,this.CustomPosY=0,this.square={},this.lines=[],this.linePosition=0,this.endPosition=0,this.ends=[],this.halfPI=Math.PI/2,this.quarterPI=Math.PI/4,this.doublePI=2*Math.PI,this.ctx=i.getContext("2d"),this.width=0,this.height=0,this.animationFrameId=null,this.observer=""}generatePCB(){this.autoResize&&(this.observer=new ResizeObserver(this.makePCB.bind(this)),this.observer.observe(this.canvas)),this.makePCB()}stopPCB(){this.observer.disconnect(),cancelAnimationFrame(this.animationFrameId)}makePCB(){this.linePosition=0,this.endPosition=0,this.animationFrameId&&cancelAnimationFrame(this.animationFrameId),this.lines.length=0,this.ends.length=0,this.width=window.innerWidth,this.height=window.innerHeight,this.canvas.width=this.width,this.canvas.height=this.height,this.squareSize=this.autoFitSizes?(this.width<this.height?this.width:this.height)/3:this.squareSize;let i=0,t=0;switch(this.location){case"Center":i=(this.width-this.squareSize)/2,t=(this.height-this.squareSize)/2;break;case"HalfLeft":i=-this.squareSize/2,t=(this.height-this.squareSize)/2;break;case"HalfRight":i=this.width-this.squareSize/2,t=(this.height-this.squareSize)/2;break;case"HalfTop":i=(this.width-this.squareSize)/2,t=-this.squareSize/2;break;case"HalfBottom":i=(this.width-this.squareSize)/2,t=this.height-this.squareSize/2;break;case"AutoRightBottom":this.width>=this.height?(i=3*(this.width-this.squareSize)/4,t=(this.height-this.squareSize)/2):(i=(this.width-this.squareSize)/2,t=3*(this.height-this.squareSize)/4);break;case"AutoLeftTop":this.width>=this.height?(i=1*(this.width-this.squareSize)/4,t=(this.height-this.squareSize)/2):(i=(this.width-this.squareSize)/2,t=1*(this.height-this.squareSize)/4);break;case"HalfRightBottom":this.width>=this.height?(i=this.width-this.squareSize/2,t=(this.height-this.squareSize)/2):(i=(this.width-this.squareSize)/2,t=this.height-this.squareSize/2);break;case"HalfLeftTop":this.width>=this.height?(i=-this.squareSize/2,t=(this.height-this.squareSize)/2):(i=(this.width-this.squareSize)/2,t=-this.squareSize/2);break;case"Custom":i=this.CustomPosX,t=this.CustomPosY}this.square={x:i,y:t,size:this.squareSize},this.ctx.lineWidth=this.autoFitSizes?Math.floor(2*(this.width<this.height?this.width:this.height)/1e3):this.lineWidth,this.lineSpacing=this.autoFitSizes?8+2*this.ctx.lineWidth:this.lineSpacing,this.createLinesFromEdges(),this.ctx.clearRect(0,0,this.width,this.height),this.ctx.strokeStyle=this.color,this.ctx.strokeRect(this.square.x,this.square.y,this.square.size,this.square.size),this.animate()}drawLine(i){this.ctx.beginPath(),this.ctx.moveTo(i.x1,i.y1),this.ctx.lineTo(i.x2,i.y2),this.ctx.stroke()}drawCircles(i){this.ctx.beginPath(),this.ctx.arc(i.x,i.y,2,0,this.doublePI),this.ctx.stroke(),this.ctx.fillStyle=this.color,this.ctx.fill()}createLinesFromEdges(){const i=Math.floor(this.square.size/this.lineSpacing);this.numEnds=4*(i-1);for(let t=1;t<i;t++){let i=this.square.x+t*this.lineSpacing,s=this.square.y;this.lines.push({x1:i,y1:s,x2:i,y2:s-this.lineSpeed,angle:-this.halfPI,length:0,lastAngle:-1})}for(let t=1;t<i;t++){let i=this.square.x+this.square.size,s=this.square.y+t*this.lineSpacing;this.lines.push({x1:i,y1:s,x2:i+this.lineSpeed,y2:s,angle:0,length:0,lastAngle:-1})}for(let t=1;t<i;t++){let i=this.square.x+t*this.lineSpacing,s=this.square.y+this.square.size;this.lines.push({x1:i,y1:s,x2:i,y2:s+this.lineSpeed,angle:this.halfPI,length:0,lastAngle:-1})}for(let t=1;t<i;t++){let i=this.square.x,s=this.square.y+t*this.lineSpacing;this.lines.push({x1:i,y1:s,x2:i-this.lineSpeed,y2:s,angle:Math.PI,length:0,lastAngle:-1})}}updateLine(i){let t=i.angle;if(i.length>=this.minLength&&Math.random()<.008){const t=(Math.random()<.5?1:-1)*this.quarterPI;i.angle+=t}const s=i.x2+this.lineSpeed*Math.cos(i.angle),e=i.y2+this.lineSpeed*Math.sin(i.angle);if(i.angle!=t&&(i.lastAngle=t),Math.random()>this.endCoefficient||i.length<=this.minLength/2)this.checkCollision(s,e)?this.lines.push({x1:i.x2,y1:i.y2,x2:s,y2:e,angle:i.lastAngle,length:i.length+this.lineSpeed,lastAngle:i.lastAngle}):this.lines.push({x1:i.x2,y1:i.y2,x2:s,y2:e,angle:i.angle,length:i.length+this.lineSpeed,lastAngle:i.lastAngle});else{let t=i.x2;Math.random()>.5?t+=1:t-=1;let s=i.y2;Math.random()>.5?s+=1:s-=1,this.ends.push({x:t,y:s})}i.finished=!0}checkCollision(i,t){for(let s of this.lines)if(Math.hypot(i-s.x2,t-s.y2)<2)return!0;return!1}animate(){this.linePosition==this.lines.length&&this.endPosition==this.ends.length&&cancelAnimationFrame(this.animationFrameId),this.lines.forEach((i=>{i.finished||this.updateLine(i)})),this.lines.slice(this.linePosition,this.lines.length).forEach((i=>this.drawLine(i))),this.linePosition=this.lines.length,this.ends.slice(this.endPosition,this.ends.length).forEach((i=>this.drawCircles(i))),this.endPosition=this.ends.length,this.ctx.clearRect(this.square.x+1,this.square.y+1,this.square.size-2,this.square.size-2),this.numEnds>this.ends.length&&(this.animationFrameId=requestAnimationFrame(this.animate.bind(this)))}}