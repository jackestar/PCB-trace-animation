class PCBTraceAnimation{constructor(i,t={}){this.traceElement=i,this.options={traceColor:t.traceColor||t.color||"#000",viaColor:t.viaColor||t.color||"#000",autoResize:void 0===t.autoResize||t.autoResize,speed:t.speed||4,gridResolution:t.gridResolution||Math.max(2,t.lineWidth||3),lineSpacing:t.lineSpacing||10,minLength:t.minLength||2*(t.speed||4),lineWidth:t.lineWidth||3,lineMargin:t.lineMargin||10,lineAngleVariation:t.lineAngleVariation||.008,lineEndCoefficient:t.lineEndCoefficient||.005},this.lines=[],this.ctx=i.getContext("2d"),this.width=0,this.height=0,this.grid=null,this.gridCols=0,this.gridRows=0,this.PIQ=Math.PI/4,this.PIT=2*Math.PI,this.PIH=Math.PI/2,this.animationFrameId=null,this.running=!1,this.resizeObserver=null}initCanvas(){this.width=window.innerWidth,this.height=window.innerHeight,this.traceElement.width=this.width,this.traceElement.height=this.height,this.ctx.lineCap="square",this.gridCols=Math.ceil(this.width/this.options.gridResolution),this.gridRows=Math.ceil(this.height/this.options.gridResolution),this.grid=new Uint8Array(this.gridCols*this.gridRows)}markGrid(i,t){if(i<0||i>=this.width||t<0||t>=this.height)return;const s=i/this.options.gridResolution|0,e=t/this.options.gridResolution|0;s>=0&&s<this.gridCols&&e>=0&&e<this.gridRows&&(this.grid[e*this.gridCols+s]=1)}isColliding(i,t){if(i<0||i>=this.width||t<0||t>=this.height)return!0;const s=i/this.options.gridResolution|0,e=t/this.options.gridResolution|0;return!(s>=0&&s<this.gridCols&&e>=0&&e<this.gridRows)||1===this.grid[e*this.gridCols+s]}markLineSegment(i,t,s,e){const n=Math.hypot(s-i,e-t),h=Math.ceil(n/(this.options.gridResolution/2));for(let n=0;n<=h;n++){const o=n/h,r=i+(s-i)*o,l=t+(e-t)*o;this.markGrid(r,l)}}drawLine(i,t,s,e=!0,n=!1){const h=this.width*i,o=this.height*t,r=e?this.width*s:this.height*s,l=h+(e?r:0),a=o+(e?0:r);this.ctx.strokeStyle=this.options.traceColor,this.ctx.lineWidth=this.options.lineWidth,this.ctx.lineCap="round",this.ctx.beginPath(),this.ctx.moveTo(h,o),this.ctx.lineTo(l,a),this.ctx.stroke(),this.markLineSegment(h,o,l,a);const d=this.options.lineSpacing+this.options.lineWidth,g=(r-this.options.lineMargin)/d;let c=this.options.lineMargin+(e?h:o);for(let i=0;i<g;i++){const i=e?c:h,t=e?o:c;this.markGrid(i,t),this.lines.push({x:i,y:t,angle:(n?Math.PI:0)+(e?this.PIH:0),dead:!1}),c+=d}}frame(){for(let i=this.lines.length-1;i>=0;i--){const t=this.lines[i],s=Math.cos(t.angle)*this.options.speed,e=Math.sin(t.angle)*this.options.speed,n=t.x+s,h=t.y+e,o=t.x+1.1*s,r=t.y+1.1*e;if(this.isColliding(o,r))this.lines.splice(i,1);else{if(this.ctx.strokeStyle=this.options.traceColor,this.ctx.lineWidth=this.options.lineWidth,this.ctx.beginPath(),this.ctx.moveTo(t.x,t.y),this.ctx.lineTo(n,h),this.ctx.stroke(),this.markLineSegment(t.x,t.y,n,h),t.x=n,t.y=h,Math.random()<this.options.lineAngleVariation){const i=Math.random()<.5?-this.PIQ:this.PIQ,s=(t.angle+i+this.PIT)%this.PIT;t.angle=s}if(Math.random()<this.options.lineEndCoefficient){this.lines.splice(i,1),this.ctx.fillStyle=this.options.viaColor,this.ctx.beginPath();const s=Math.max(1,1.2*this.options.lineWidth);this.ctx.arc(t.x,t.y,s,0,this.PIT),this.ctx.fill()}}}}start(){if(this.running)return;this.initCanvas(),this.options.autoResize&&"undefined"!=typeof ResizeObserver&&(this.resizeObserver&&this.resizeObserver.disconnect(),this.resizeObserver=new ResizeObserver((()=>this.initCanvas())),this.resizeObserver.observe(this.traceElement)),this.running=!0;const i=()=>{this.running&&(this.frame(),this.animationFrameId=requestAnimationFrame(i))};i()}stop(){this.running=!1,this.animationFrameId&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=null),this.resizeObserver&&(this.resizeObserver.disconnect(),this.resizeObserver=null)}}